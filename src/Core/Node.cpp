// Copyright (c) 2012-2018, The CryptoNote developers, The Bytecoin developers.
// Licensed under the GNU Lesser General Public License. See LICENSE for details.

#include "Node.hpp"
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <iostream>
#include "Config.hpp"
#include "CryptoNoteTools.hpp"
#include "TransactionBuilder.hpp"
#include "TransactionExtra.hpp"
#include "common/Base58.hpp"
#include "common/JsonValue.hpp"
#include "http/Client.hpp"
#include "http/Server.hpp"
#include "platform/PathTools.hpp"
#include "platform/PreventSleep.hpp"
#include "platform/Time.hpp"
#include "seria/BinaryInputStream.hpp"
#include "seria/BinaryOutputStream.hpp"
#include "seria/KVBinaryInputStream.hpp"
#include "seria/KVBinaryOutputStream.hpp"
#include "version.hpp"

using namespace cn;

Node::Node(logging::ILogger &log, const Config &config, BlockChainState &block_chain)
    : m_block_chain(block_chain)
    , m_config(config)
    , m_block_chain_was_far_behind(true)
    , m_log(log, "Node")
    , m_peer_db(log, config, "peer_db")
    , m_p2p(log, config, m_peer_db, std::bind(&Node::client_factory, this, _1))
    , multicast(config.multicast_address, config.multicast_port, std::bind(&Node::on_multicast, this, _1, _2, _3))
    , m_multicast_timer(std::bind(&Node::send_multicast, this))
    , m_start_time(m_p2p.get_local_time())
    , m_commit_timer(std::bind(&Node::db_commit, this))
    , log_request_timestamp(std::chrono::steady_clock::now())
    , log_response_timestamp(std::chrono::steady_clock::now())
    , m_pow_checker(block_chain.get_currency(), platform::EventLoop::current()) {
	const std::string old_path = platform::get_default_data_directory(CRYPTONOTE_NAME);
	const std::string new_path = config.get_data_folder();

	if (!config.bytecoind_bind_ip.empty() && config.bytecoind_bind_port != 0)
		m_api = std::make_unique<http::Server>(config.bytecoind_bind_ip, config.bytecoind_bind_port,
		    std::bind(&Node::on_api_http_request, this, _1, _2, _3),
		    std::bind(&Node::on_api_http_disconnect, this, _1));

	m_commit_timer.once(float(m_config.db_commit_period_blockchain));
	advance_long_poll();
	send_multicast();
}

Node::~Node() {}  // we have unique_ptr to incomplete type

void Node::send_multicast() {
	if (!m_config.use_multicast())
		return;
	//	std::cout << "sending multicast about node listening on port=" << m_config.p2p_external_port << std::endl;
	BinaryArray ha = P2PProtocolBasic::create_multicast_announce(
	    m_config.network_id, m_block_chain.get_currency().genesis_block_hash, m_config.p2p_external_port);
	platform::UDPMulticast::send(m_config.multicast_address, m_config.multicast_port, ha.data(), ha.size());
	m_multicast_timer.once(m_config.multicast_period);
}

void Node::on_multicast(const std::string &addr, const unsigned char *data, size_t size) {
	if (!m_config.use_multicast())
		return;
	NetworkAddress na;
	na.port = P2PProtocolBasic::parse_multicast_announce(
	    data, size, m_config.network_id, m_block_chain.get_currency().genesis_block_hash);
	if (!na.port)
		return;
	if (common::parse_ip_address(addr, &na.ip)) {
		if (m_peer_db.add_incoming_peer(na, m_p2p.get_local_time()))
			m_log(logging::INFO) << "Adding peer from multicast announce addr=" << na << std::endl;
	}
	// We do not receive multicast from loopback, so we just guess peer could be from localhost
	if (common::parse_ip_address("127.0.0.1", &na.ip)) {
		if (m_peer_db.add_incoming_peer(na, m_p2p.get_local_time()))
			m_log(logging::INFO) << "Adding local peer from multicast announce addr=" << na << std::endl;
	}
	m_p2p.peers_updated();
}

void Node::db_commit() {
	m_block_chain.db_commit();
	m_commit_timer.once(float(m_config.db_commit_period_blockchain));
}

void Node::remove_chain_block(std::map<Hash, DownloadInfo>::iterator it) {
	invariant(it->second.chain_counter > 0, "");
	it->second.chain_counter -= 1;
	if (it->second.chain_counter == 0 && !it->second.preparing)
		chain_blocks.erase(it);
}

void Node::advance_all_downloads() {
	for (auto &&who : m_broadcast_protocols)
		who->advance_blocks();
}

bool Node::on_idle() {
	auto idle_start     = std::chrono::steady_clock::now();
	Hash was_top_bid    = m_block_chain.get_tip_bid();
	bool on_idle_result = false;
	if (m_block_chain.get_tip_height() >= m_block_chain.internal_import_known_height()) {
		for (size_t s = 0; s != 10; ++s) {
			bool on_idle_result_s = false;
			std::vector<P2PProtocolBytecoin *> bp_copy{m_broadcast_protocols.begin(), m_broadcast_protocols.end()};
			// We need bp_copy because on_idle can disconnect, modifying m_broadcast_protocols
			for (auto &&who : bp_copy)
				on_idle_result_s = who->on_idle(idle_start) | on_idle_result_s;
			if (!on_idle_result_s)
				break;
			on_idle_result = true;
		}
	}
	if (m_block_chain.get_tip_height() < m_block_chain.internal_import_known_height())
		m_block_chain.internal_import();
	if (m_block_chain.get_tip_bid() != was_top_bid) {
		advance_long_poll();
	}
	advance_all_downloads();
	return on_idle_result;
}

bool Node::check_trust(const p2p::ProofOfTrust &tr) {
	Timestamp local_time = platform::now_unix_timestamp();
	Timestamp time_delta = local_time > tr.time ? local_time - tr.time : tr.time - local_time;

	if (time_delta > 24 * 60 * 60)
		return false;
	if (m_last_stat_request_time >= tr.time)
		return false;
	if (m_p2p.get_unique_number() != tr.peer_id)
		return false;

	Hash h = tr.get_hash();
	if (!crypto::check_signature(h, m_config.trusted_public_key, tr.sign))
		return false;
	m_last_stat_request_time = tr.time;
	return true;
}

void Node::advance_long_poll() {
	const auto now = m_p2p.get_local_time();
	if (!m_prevent_sleep && m_block_chain.get_tip().timestamp < now - 86400)
		m_prevent_sleep = std::make_unique<platform::PreventSleep>("Downloading blockchain");
	if (m_prevent_sleep &&
	    m_block_chain.get_tip().timestamp > now - m_block_chain.get_currency().block_future_time_limit * 2)
		m_prevent_sleep = nullptr;
	if (m_long_poll_http_clients.empty())
		return;
	const api::cnd::GetStatus::Response resp = create_status_response();

	for (auto lit = m_long_poll_http_clients.begin(); lit != m_long_poll_http_clients.end();) {
		const bool method_status = lit->original_json_request.get_method() == api::cnd::GetStatus::method() ||
		                           lit->original_json_request.get_method() == api::cnd::GetStatus::method2();
		if (!resp.ready_for_longpoll(lit->original_get_status)) {
			++lit;
			continue;
		}
		const common::JsonValue &jid = lit->original_json_request.get_id().get();
		http::ResponseBody last_http_response;
		last_http_response.r.headers.push_back({"Content-Type", "application/json; charset=utf-8"});
		last_http_response.r.status             = 200;
		last_http_response.r.http_version_major = lit->original_request.r.http_version_major;
		last_http_response.r.http_version_minor = lit->original_request.r.http_version_minor;
		last_http_response.r.keep_alive         = lit->original_request.r.keep_alive;
		if (method_status) {
			last_http_response.set_body(json_rpc::create_response_body(resp, jid));
		} else {
			try {
				api::cnd::GetBlockTemplate::Request gbt_req;
				lit->original_json_request.load_params(gbt_req);
				api::cnd::GetBlockTemplate::Response gbt_res;
				getblocktemplate(gbt_req, gbt_res);
				last_http_response.set_body(json_rpc::create_response_body(gbt_res, jid));
			} catch (const json_rpc::Error &err) {
				last_http_response.set_body(json_rpc::create_error_response_body(err, jid));
			} catch (const std::exception &e) {
				json_rpc::Error json_err(json_rpc::INTERNAL_ERROR, common::what(e));
				last_http_response.set_body(json_rpc::create_error_response_body(json_err, jid));
			}
		}
		lit->original_who->write(std::move(last_http_response));
		lit = m_long_poll_http_clients.erase(lit);
	}
}

static const std::string beautiful_index_start =
    R"(<html><head><meta http-equiv='refresh' content='30'/></head><body><table valign="middle"><tr><td width="30px">
<p><img src="data:image/png;base64,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" style="width: 30px;"></p></td><td>)" CRYPTONOTE_NAME R"(d &bull; version
)";
static const std::string beautiful_index_finish = " </td></tr></table></body></html>";
static const std::string robots_txt             = "User-agent: *\r\nDisallow: /";

bool Node::on_api_http_request(http::Client *who, http::RequestBody &&request, http::ResponseBody &response) {
	response.r.add_headers_nocache();
	if (request.r.uri == "/robots.txt") {
		response.r.headers.push_back({"Content-Type", "text/plain; charset=UTF-8"});
		response.r.status = 200;
		response.set_body(std::string(robots_txt));
		return true;
	}
	bool good_auth =
	    m_config.bytecoind_authorization.empty() || request.r.basic_authorization == m_config.bytecoind_authorization;
	bool good_auth_private = m_config.bytecoind_authorization_private.empty() ||
	                         request.r.basic_authorization == m_config.bytecoind_authorization_private;
	if (!good_auth && !good_auth_private)  // Private methods will check for private authorization again
		throw http::ErrorAuthorization("Blockchain");
	if (request.r.uri == "/" || request.r.uri == "/index.html") {
		response.r.headers.push_back({"Content-Type", "text/html; charset=UTF-8"});
		response.r.status = 200;
		auto stat         = create_status_response();
		float sync_precantage = static_cast<int>(((stat.top_block_height/(stat.top_known_block_height/100)))*100+0.5) / 100.0;
		auto body = beautiful_index_start + app_version() + " &bull; " + m_config.net + "net &bull; sync status " +
		            common::to_string(stat.top_block_height) + "/" + common::to_string(stat.top_known_block_height) + " (" +common::to_string(sync_precantage) + " %)" +
		            beautiful_index_finish;
		if (m_config.net != "main")
			boost::replace_all(body, "#f04086", "#00afa5");
		response.set_body(std::move(body));
		return true;
	}
	if (request.r.uri == api::cnd::url()) {
		if (!on_json_rpc(who, std::move(request), response))
			return false;
		response.r.status = 200;
		return true;
	}
	if (request.r.uri == api::cnd::binary_url()) {
		if (!on_binary_rpc(who, std::move(request), response))
			return false;
		response.r.status = 200;
		return true;
	}
	response.r.status = 404;
	response.set_body("<html><body>404 Not Found</body></html>");
	return true;
}

void Node::on_api_http_disconnect(http::Client *who) {
	for (auto lit = m_long_poll_http_clients.begin(); lit != m_long_poll_http_clients.end();)
		if (lit->original_who == who)
			lit = m_long_poll_http_clients.erase(lit);
		else
			++lit;
}

const std::unordered_map<std::string, Node::BINARYRPCHandlerFunction> Node::m_binaryrpc_handlers = {
    {api::cnd::SyncBlocks::bin_method(), json_rpc::make_binary_member_method(&Node::on_sync_blocks)},
    {api::cnd::SyncMemPool::bin_method(), json_rpc::make_binary_member_method(&Node::on_sync_mempool)}};

std::unordered_map<std::string, Node::JSONRPCHandlerFunction> Node::m_jsonrpc_handlers = {
    {api::cnd::GetLastBlockHeaderLegacy::method(), json_rpc::make_member_method(&Node::on_get_last_block_header)},
    {api::cnd::GetBlockHeaderByHashLegacy::method(), json_rpc::make_member_method(&Node::on_get_block_header_by_hash)},
    {api::cnd::GetBlockHeaderByHeightLegacy::method(),
        json_rpc::make_member_method(&Node::on_get_block_header_by_height)},
    {api::cnd::GetBlockTemplate::method(), json_rpc::make_member_method(&Node::on_getblocktemplate)},
    {api::cnd::GetBlockTemplate::method_legacy(), json_rpc::make_member_method(&Node::on_getblocktemplate)},
    {api::cnd::GetCurrencyId::method(), json_rpc::make_member_method(&Node::on_get_currency_id)},
    {api::cnd::GetCurrencyId::method_legacy(), json_rpc::make_member_method(&Node::on_get_currency_id)},
    {api::cnd::SubmitBlock::method(), json_rpc::make_member_method(&Node::on_submitblock)},
    {api::cnd::SubmitBlockLegacy::method(), json_rpc::make_member_method(&Node::on_submitblock_legacy)},
    {api::cnd::GetRandomOutputs::method(), json_rpc::make_member_method(&Node::on_get_random_outputs)},
    {api::cnd::GetStatus::method(), json_rpc::make_member_method(&Node::on_get_status)},
    {api::cnd::GetStatus::method2(), json_rpc::make_member_method(&Node::on_get_status)},
    {api::cnd::GetStatistics::method(), json_rpc::make_member_method(&Node::on_get_statistics)},
    {api::cnd::GetArchive::method(), json_rpc::make_member_method(&Node::on_get_archive)},
    {api::cnd::SendTransaction::method(), json_rpc::make_member_method(&Node::on_send_transaction)},
    {api::cnd::CheckSendproof::method(), json_rpc::make_member_method(&Node::on_check_sendproof)},
    {api::cnd::SyncBlocks::method(), json_rpc::make_member_method(&Node::on_sync_blocks)},
    {api::cnd::GetRawBlock::method(), json_rpc::make_member_method(&Node::on_get_raw_block)},
    {api::cnd::GetBlockHeader::method(), json_rpc::make_member_method(&Node::on_get_block_header)},
    {api::cnd::GetRawTransaction::method(), json_rpc::make_member_method(&Node::on_get_raw_transaction)},
    {api::cnd::SyncMemPool::method(), json_rpc::make_member_method(&Node::on_sync_mempool)}};

bool Node::on_get_random_outputs(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::GetRandomOutputs::Request &&request, api::cnd::GetRandomOutputs::Response &response) {
	Height confirmed_height_or_depth = api::ErrorWrongHeight::fix_height_or_depth(
	    request.confirmed_height_or_depth, m_block_chain.get_tip_height(), true, false);
	api::BlockHeader confirmed_header = m_block_chain.get_tip();
	Hash confirmed_hash;
	invariant(m_block_chain.get_chain(confirmed_height_or_depth, &confirmed_hash), "");
	invariant(m_block_chain.get_header(confirmed_hash, &confirmed_header), "");
	for (uint64_t amount : request.amounts) {
		auto random_outputs =
		    m_block_chain.get_random_outputs(confirmed_header.major_version, amount, request.output_count,
		        confirmed_height_or_depth, confirmed_header.timestamp, confirmed_header.timestamp_median);
		auto &outs = response.outputs[amount];
		outs.insert(outs.end(), random_outputs.begin(), random_outputs.end());
	}
	return true;
}

api::cnd::GetStatus::Response Node::create_status_response() const {
	api::cnd::GetStatus::Response res;
	res.top_block_height       = m_block_chain.get_tip_height();
	res.top_known_block_height = res.top_block_height;
	for (auto &&gc : m_broadcast_protocols)
		res.top_known_block_height = std::max(res.top_known_block_height, gc->get_peer_sync_data().current_height);
	res.top_known_block_height =
	    std::max<Height>(res.top_known_block_height, m_block_chain.internal_import_known_height());
	for (auto &&pb : m_broadcast_protocols)
		if (pb->is_incoming())
			res.incoming_peer_count += 1;
		else
			res.outgoing_peer_count += 1;
	api::BlockHeader tip                 = m_block_chain.get_tip();
	res.top_block_hash                   = m_block_chain.get_tip_bid();
	res.top_block_timestamp              = tip.timestamp;
	res.top_block_timestamp_median       = tip.timestamp_median;
	res.top_block_difficulty             = tip.difficulty;
	res.top_block_cumulative_difficulty  = tip.cumulative_difficulty;
	res.recommended_fee_per_byte         = m_block_chain.get_currency().coin() / 1000000;  // TODO - calculate
	res.recommended_max_transaction_size = m_block_chain.get_currency().get_recommended_max_transaction_size();
	res.transaction_pool_version         = m_block_chain.get_tx_pool_version();
	return res;
}

void Node::broadcast(P2PProtocolBytecoin *exclude, const BinaryArray &data) {
	for (auto &&p : m_broadcast_protocols)
		if (p != exclude)
			p->P2PProtocol::send(BinaryArray(data));  // Move is impossible here
}
void Node::broadcast(P2PProtocolBytecoin *exclude, const BinaryArray &data_v1, const BinaryArray &data_v4) {
	for (auto &&p : m_broadcast_protocols)
		if (p != exclude)
			p->P2PProtocol::send(BinaryArray(
			    p->get_peer_version() >= P2PProtocolVersion::AMETHYST ? data_v4 : data_v1));  // Move is impossible here
}

bool Node::on_get_status(http::Client *who, http::RequestBody &&raw_request, json_rpc::Request &&raw_js_request,
    api::cnd::GetStatus::Request &&req, api::cnd::GetStatus::Response &res) {
	res = create_status_response();
	if (!res.ready_for_longpoll(req)) {
		//		m_log(logging::INFO) << "on_get_status will long poll, json="
		// << raw_request.body << std::endl;
		LongPollClient lpc;
		lpc.original_who          = who;
		lpc.original_request      = raw_request;
		lpc.original_json_request = std::move(raw_js_request);
		lpc.original_get_status   = req;
		m_long_poll_http_clients.push_back(lpc);
		return false;
	}
	return true;
}

api::cnd::GetStatistics::Response Node::create_statistics_response(const api::cnd::GetStatistics::Request &req) const {
	api::cnd::GetStatistics::Response res;
	res.peer_id = m_p2p.get_unique_number();
	if (req.need_connected_peers) {
		for (auto &&p : m_broadcast_protocols) {
			ConnectionDesc desc;
			desc.address               = p->get_address();
			desc.is_incoming           = p->is_incoming();
			desc.p2p_version           = p->get_peer_version();
			desc.peer_id               = p->get_peer_unique_number();
			desc.top_block_desc.hash   = p->get_peer_sync_data().top_id;
			desc.top_block_desc.height = p->get_peer_sync_data().current_height;
			res.connected_peers.push_back(desc);
		}
	}
	if (req.need_peer_lists) {
		res.peer_list_gray = m_peer_db.get_peer_list_gray();
		res.peer_list_gray = m_peer_db.get_peer_list_white();
	}
	res.platform           = platform::get_platform_name();
	res.version            = cn::app_version();
	res.net                = m_config.net;
	res.genesis_block_hash = m_block_chain.get_currency().genesis_block_hash;
	res.start_time         = m_start_time;
	m_block_chain.fill_statistics(res);
	return res;
}

bool Node::on_get_statistics(http::Client *, http::RequestBody &&http_request, json_rpc::Request &&,
    api::cnd::GetStatistics::Request &&req, api::cnd::GetStatistics::Response &res) {
	bool good_auth_private = m_config.bytecoind_authorization_private.empty() ||
	                         http_request.r.basic_authorization == m_config.bytecoind_authorization_private;
	if (!good_auth_private)
		throw http::ErrorAuthorization("Statistics");
	res = create_statistics_response(req);
	return true;
}

bool Node::on_get_archive(http::Client *, http::RequestBody &&http_request, json_rpc::Request &&,
    api::cnd::GetArchive::Request &&req, api::cnd::GetArchive::Response &resp) {
	bool good_auth_private = m_config.bytecoind_authorization_private.empty() ||
	                         http_request.r.basic_authorization == m_config.bytecoind_authorization_private;
	if (!good_auth_private)
		throw http::ErrorAuthorization("Archive");
	m_block_chain.read_archive(std::move(req), resp);
	return true;
}

// mixed_public_keys can be null if keys not needed
void Node::fill_transaction_info(
    const TransactionPrefix &tx, api::Transaction *api_tx, std::vector<std::vector<PublicKey>> *mixed_public_keys) {
	api_tx->unlock_block_or_timestamp = tx.unlock_block_or_timestamp;
	api_tx->extra                     = tx.extra;
	api_tx->anonymity                 = std::numeric_limits<size_t>::max();
	api_tx->public_key                = extra_get_transaction_public_key(tx.extra);
	api_tx->prefix_hash               = get_transaction_prefix_hash(tx);
	api_tx->inputs_hash               = get_transaction_inputs_hash(tx);
	extra_get_payment_id(tx.extra, api_tx->payment_id);
	Amount input_amount = 0;
	for (const auto &input : tx.inputs) {
		if (input.type() == typeid(InputKey)) {
			const InputKey &in = boost::get<InputKey>(input);
			api_tx->anonymity  = std::min(api_tx->anonymity, in.output_indexes.size() - 1);
			input_amount += in.amount;
			if (mixed_public_keys)
				mixed_public_keys->push_back(m_block_chain.get_mixed_public_keys(in));
		}
	}
	Amount output_amount = get_tx_sum_outputs(tx);
	api_tx->amount       = output_amount;
	if (input_amount >= output_amount)
		api_tx->fee = input_amount - output_amount;
	if (api_tx->anonymity == std::numeric_limits<size_t>::max())
		api_tx->anonymity = 0;  // No key inputs
}

bool Node::on_sync_blocks(http::Client *, http::RequestBody &&, json_rpc::Request &&json_req,
    api::cnd::SyncBlocks::Request &&req, api::cnd::SyncBlocks::Response &res) {
	if (req.sparse_chain.empty())
		throw std::runtime_error("Empty sparse chain - must include at least 1 block (usually genesis)");
	if (req.sparse_chain.back() == Hash{})  // We allow to ask for "whatever genesis bid. Useful for explorer, etc."
		req.sparse_chain.back() = m_block_chain.get_genesis_bid();
	if (req.max_count > m_config.rpc_sync_blocks_max_count)
		req.max_count = m_config.rpc_sync_blocks_max_count;
	auto first_block_timestamp = req.first_block_timestamp < m_block_chain.get_currency().block_future_time_limit
	                                 ? 0
	                                 : req.first_block_timestamp - m_block_chain.get_currency().block_future_time_limit;
	Height full_offset = m_block_chain.get_timestamp_lower_bound_height(first_block_timestamp);
	Height start_height;
	std::vector<Hash> subchain =
	    m_block_chain.get_sync_headers_chain(req.sparse_chain, &start_height, req.max_count + 1);
	// Will throw if no common subchain
	if (!subchain.empty() && start_height != 0) {
		subchain.erase(subchain.begin());  // Caller never needs common block she already has
		start_height += 1;                 // Except if genesis (caller knows hash, but has no block)
	} else if (subchain.size() > req.max_count) {
		subchain.pop_back();
	}
	if (full_offset >= start_height + subchain.size()) {
		start_height = full_offset;
		subchain.clear();
		while (subchain.size() < req.max_count) {
			Hash ha;
			if (!m_block_chain.get_chain(start_height + static_cast<Height>(subchain.size()), &ha))
				break;
			subchain.push_back(ha);
		}
	} else if (full_offset > start_height) {
		subchain.erase(subchain.begin(), subchain.begin() + (full_offset - start_height));
		start_height = full_offset;
	}

	res.start_height = start_height;
	res.blocks.resize(subchain.size());
	size_t total_size = 0;
	for (size_t i = 0; i != subchain.size(); ++i) {
		const auto &bhash = subchain[i];
		auto &res_block   = res.blocks[i];
		invariant(
		    m_block_chain.get_header(bhash, &res_block.header), "Block header must be there, but it is not there");

		//		BlockChainState::BlockGlobalIndices output_indexes;
		// if (res.blocks[i].header.timestamp >= req.first_block_timestamp) //
		// commented out becuase empty Block cannot be serialized
		{
			RawBlock rb;
			invariant(m_block_chain.get_block(bhash, &rb), "Block must be there, but it is not there");
			Block block(rb);
			res_block.transactions.resize(block.transactions.size() + 1);
			res_block.transactions.at(0).hash = get_transaction_hash(block.header.base_transaction);
			res_block.transactions.at(0).size = seria::binary_size(block.header.base_transaction);
			if (req.need_redundant_data) {
				fill_transaction_info(block.header.base_transaction, &res_block.transactions.at(0), nullptr);
				res_block.transactions.at(0).block_height = start_height + static_cast<Height>(i);
				res_block.transactions.at(0).block_hash   = bhash;
				res_block.transactions.at(0).coinbase     = true;
				res_block.transactions.at(0).timestamp    = block.header.timestamp;
			}
			res_block.raw_header = std::move(block.header);
			res_block.raw_transactions.reserve(block.transactions.size());
			for (size_t tx_index = 0; tx_index != block.transactions.size(); ++tx_index) {
				res_block.transactions.at(tx_index + 1).hash = res_block.raw_header.transaction_hashes.at(tx_index);
				res_block.transactions.at(tx_index + 1).size = rb.transactions.at(tx_index).size();
				if (req.need_redundant_data) {
					fill_transaction_info(
					    block.transactions.at(tx_index), &res_block.transactions.at(tx_index + 1), nullptr);
					res_block.transactions.at(tx_index + 1).block_height = start_height + static_cast<Height>(i);
					res_block.transactions.at(tx_index + 1).block_hash   = bhash;
					res_block.transactions.at(tx_index + 1).timestamp    = res_block.raw_header.timestamp;
				}
				res_block.raw_transactions.push_back(std::move(block.transactions.at(tx_index)));
			}
			invariant(m_block_chain.read_block_output_global_indices(bhash, &res_block.output_stack_indexes),
			    "Invariant dead - bid is in chain but blockchain has no block indices");
		}
		total_size += res_block.header.transactions_size;
		if (total_size >= req.max_size) {
			res.blocks.resize(i + 1);
			break;
		}
	}
	res.status = create_status_response();
	return true;
}

bool Node::on_sync_mempool(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::SyncMemPool::Request &&req, api::cnd::SyncMemPool::Response &res) {
	const auto &pool = m_block_chain.get_memory_state_transactions();
	for (auto &&ex : req.known_hashes)
		if (pool.count(ex) == 0)
			res.removed_hashes.push_back(ex);
	for (auto &&tx : pool)
		if (!std::binary_search(req.known_hashes.begin(), req.known_hashes.end(), tx.first)) {
			res.added_raw_transactions.push_back(tx.second.tx);
			res.added_transactions.push_back(api::Transaction{});
			if (req.need_redundant_data)
				fill_transaction_info(tx.second.tx, &res.added_transactions.back(), nullptr);
			res.added_transactions.back().hash      = tx.first;
			res.added_transactions.back().timestamp = tx.second.timestamp;
			res.added_transactions.back().amount    = tx.second.amount;
			res.added_transactions.back().fee       = tx.second.fee;
			res.added_transactions.back().size      = tx.second.binary_tx.size();
		}
	res.status = create_status_response();
	return true;
}

bool Node::on_get_block_header(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::GetBlockHeader::Request &&request, api::cnd::GetBlockHeader::Response &response) {
	if (request.hash != Hash{} && request.height_or_depth != std::numeric_limits<api::HeightOrDepth>::max())
		throw json_rpc::Error(
		    json_rpc::INVALID_REQUEST, "You cannot specify both hash and height_or_depth to this method");
	if (request.hash != Hash{}) {
		if (!m_block_chain.get_header(request.hash, &response.block_header))
			throw api::ErrorHashNotFound("Block not found in either main or side chains", request.hash);
	} else {
		Height height_or_depth = api::ErrorWrongHeight::fix_height_or_depth(
		    request.height_or_depth, m_block_chain.get_tip_height(), true, true);
		invariant(
		    m_block_chain.get_chain(height_or_depth, &request.hash), "");  // after fix_height it must always succeed
		invariant(m_block_chain.get_header(request.hash, &response.block_header), "");
	}
	response.orphan_status = !m_block_chain.in_chain(response.block_header.height, response.block_header.hash);
	response.depth =
	    api::HeightOrDepth(response.block_header.height) - api::HeightOrDepth(m_block_chain.get_tip_height()) - 1;
	return true;
}
bool Node::on_get_raw_block(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::GetRawBlock::Request &&request, api::cnd::GetRawBlock::Response &response) {
	if (request.hash != Hash{} && request.height_or_depth != std::numeric_limits<api::HeightOrDepth>::max())
		throw json_rpc::Error(
		    json_rpc::INVALID_REQUEST, "You cannot specify both hash and height_or_depth to this method");
	if (request.hash != Hash{}) {
		if (!m_block_chain.get_header(request.hash, &response.block.header))
			throw api::ErrorHashNotFound("Block not found in either main or side chains", request.hash);
	} else {
		Height height_or_depth = api::ErrorWrongHeight::fix_height_or_depth(
		    request.height_or_depth, m_block_chain.get_tip_height(), true, true);
		invariant(
		    m_block_chain.get_chain(height_or_depth, &request.hash), "");  // after fix_height it must always succeed
		invariant(m_block_chain.get_header(request.hash, &response.block.header), "");
	}
	RawBlock rb;
	invariant(m_block_chain.get_block(request.hash, &rb), "Block must be there, but it is not there");
	Block block(rb);

	api::RawBlock &b = response.block;
	b.transactions.resize(block.transactions.size() + 1);
	b.transactions.at(0).hash = get_transaction_hash(block.header.base_transaction);
	b.transactions.at(0).size = seria::binary_size(block.header.base_transaction);
	fill_transaction_info(block.header.base_transaction, &b.transactions.at(0), nullptr);
	b.transactions.at(0).block_height = b.header.height;
	b.transactions.at(0).block_hash   = b.header.hash;
	b.transactions.at(0).coinbase     = true;
	b.transactions.at(0).timestamp    = block.header.timestamp;
	b.raw_header                      = std::move(block.header);
	b.raw_transactions.reserve(block.transactions.size());
	for (size_t tx_index = 0; tx_index != block.transactions.size(); ++tx_index) {
		b.transactions.at(tx_index + 1).hash = b.raw_header.transaction_hashes.at(tx_index);
		b.transactions.at(tx_index + 1).size = rb.transactions.at(tx_index).size();
		fill_transaction_info(block.transactions.at(tx_index), &b.transactions.at(tx_index + 1), nullptr);
		b.transactions.at(tx_index + 1).block_height = b.header.height;
		b.transactions.at(tx_index + 1).block_hash   = b.header.hash;
		b.transactions.at(tx_index + 1).timestamp    = b.raw_header.timestamp;
		b.raw_transactions.push_back(std::move(block.transactions.at(tx_index)));
	}
	m_block_chain.read_block_output_global_indices(request.hash, &b.output_stack_indexes);
	// If block not in main chain - global indices will be empty
	response.orphan_status = !m_block_chain.in_chain(b.header.height, b.header.hash);
	response.depth = api::HeightOrDepth(b.header.height) - api::HeightOrDepth(m_block_chain.get_tip_height()) - 1;
	return true;
}

bool Node::on_get_raw_transaction(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::GetRawTransaction::Request &&req, api::cnd::GetRawTransaction::Response &res) {
	const auto &pool = m_block_chain.get_memory_state_transactions();
	auto tit         = pool.find(req.hash);
	if (tit != pool.end()) {
		res.raw_transaction = static_cast<const TransactionPrefix &>(tit->second.tx);
		fill_transaction_info(tit->second.tx, &res.transaction, &res.mixed_public_keys);
		res.transaction.fee          = tit->second.fee;
		res.transaction.hash         = req.hash;
		res.transaction.block_height = m_block_chain.get_tip_height() + 1;
		res.transaction.timestamp    = tit->second.timestamp;
		res.transaction.size         = tit->second.binary_tx.size();
		return true;
	}
	BinaryArray binary_tx;
	Transaction tx;
	size_t index_in_block = 0;
	if (m_block_chain.get_transaction(
	        req.hash, &binary_tx, &res.transaction.block_height, &res.transaction.block_hash, &index_in_block)) {
		api::BlockHeader bh;
		invariant(m_block_chain.get_header(res.transaction.block_hash, &bh, res.transaction.block_height), "");
		res.transaction.timestamp = bh.timestamp;
		res.transaction.size      = binary_tx.size();
		seria::from_binary(tx, binary_tx);
		res.raw_transaction = static_cast<const TransactionPrefix &>(tx);
		fill_transaction_info(tx, &res.transaction, &res.mixed_public_keys);
		res.transaction.coinbase = (index_in_block == 0);
		res.transaction.hash     = req.hash;
		res.transaction.fee      = get_tx_fee(res.raw_transaction);
		return true;
	}
	throw api::ErrorHashNotFound(
	    "Transaction not found in main chain or memory pool. You cannot get transactions from side chains with this method.",
	    req.hash);
}

bool Node::on_send_transaction(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::SendTransaction::Request &&request, api::cnd::SendTransaction::Response &response) {
	response.send_result = "broadcast";

	p2p::RelayTransactions::Notify msg;
	p2p::RelayTransactions::Notify msg_v4;
	//	Height conflict_height =
	//	    m_block_chain.get_currency().max_block_height;  // So will not be accidentally viewed as confirmed
	Transaction tx;
	try {
		seria::from_binary(tx, request.binary_transaction);
		const Hash tid = get_transaction_hash(tx);
		if (m_block_chain.add_transaction(tid, tx, request.binary_transaction, m_p2p.get_local_time(), "json_rpc")) {
			msg.txs.push_back(request.binary_transaction);
			TransactionDesc desc;
			desc.hash                       = tid;
			desc.size                       = request.binary_transaction.size();
			desc.fee                        = get_tx_fee(tx);
			Height newest_referenced_height = 0;
			invariant(m_block_chain.get_largest_referenced_height(tx, &newest_referenced_height), "");
			invariant(m_block_chain.get_chain(newest_referenced_height, &desc.newest_referenced_block), "");
			msg_v4.transaction_descs.push_back(desc);

			BinaryArray raw_msg    = LevinProtocol::send(msg);
			BinaryArray raw_msg_v4 = LevinProtocol::send(msg_v4);
			broadcast(nullptr, raw_msg, raw_msg_v4);
			advance_long_poll();
		}
	} catch (const ConsensusErrorOutputDoesNotExist &ex) {
		throw api::cnd::SendTransaction::Error(api::cnd::SendTransaction::WRONG_OUTPUT_REFERENCE, common::what(ex),
		    m_block_chain.get_currency().max_block_height);
	} catch (const ConsensusErrorBadOutputOrSignature &ex) {
		throw api::cnd::SendTransaction::Error(
		    api::cnd::SendTransaction::WRONG_OUTPUT_REFERENCE, common::what(ex), ex.conflict_height);
	} catch (const ConsensusErrorOutputSpent &ex) {
		throw api::cnd::SendTransaction::Error(
		    api::cnd::SendTransaction::OUTPUT_ALREADY_SPENT, common::what(ex), ex.conflict_height);
	} catch (const std::exception &ex) {
		std::throw_with_nested(api::cnd::SendTransaction::Error(
		    api::cnd::SendTransaction::INVALID_TRANSACTION_BINARY_FORMAT, common::what(ex), 0));
	}
	return true;
}

void Node::check_sendproof(const SendproofLegacy &sp, api::cnd::CheckSendproof::Response &response) const {
	BinaryArray binary_tx;
	Height height = 0;
	Hash block_hash;
	size_t index_in_block = 0;
	if (!m_block_chain.get_transaction(sp.transaction_hash, &binary_tx, &height, &block_hash, &index_in_block)) {
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::NOT_IN_MAIN_CHAIN, "Transaction is not in main chain");
	}
	Transaction tx;
	seria::from_binary(tx, binary_tx);
	const Hash message_hash = crypto::cn_fast_hash(sp.message.data(), sp.message.size());
	if (tx.version >= m_block_chain.get_currency().amethyst_transaction_version)
		throw api::cnd::CheckSendproof::Error(api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION,
		    "Legacy proof cannot be used for amethyst transactions");
	AccountAddress address;
	if (!m_block_chain.get_currency().parse_account_address_string(sp.address, &address))
		throw api::ErrorAddress(
		    api::ErrorAddress::ADDRESS_FAILED_TO_PARSE, "Failed to parse sendproof address", sp.address);
	if (address.type() != typeid(AccountAddressLegacy))
		throw api::cnd::CheckSendproof::Error(api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION,
		    "Transaction version too low to contain address of type other than simple");
	auto &addr              = boost::get<AccountAddressLegacy>(address);
	PublicKey tx_public_key = extra_get_transaction_public_key(tx.extra);
	if (!crypto::check_sendproof(tx_public_key, addr.V, sp.derivation, message_hash, sp.signature)) {
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::WRONG_SIGNATURE, "Proof object does not match transaction or was tampered with");
	}
	Amount total_amount = 0;
	size_t out_index    = 0;
	for (const auto &output : tx.outputs) {
		if (output.type() == typeid(OutputKey)) {
			const auto &key_output    = boost::get<OutputKey>(output);
			const PublicKey spend_key = underive_address_S(sp.derivation, out_index, key_output.public_key);
			if (spend_key == addr.S) {
				total_amount += key_output.amount;
				response.output_indexes.push_back(out_index);
			}
		}
		++out_index;
	}
	if (total_amount == 0)
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION, "No transfers found to proof address");
	response.transaction_hash = sp.transaction_hash;
	response.address          = sp.address;
	response.message          = sp.message;
	response.amount           = total_amount;
}

void Node::check_sendproof(const BinaryArray &data_inside_base58, api::cnd::CheckSendproof::Response &response) const {
	common::MemoryInputStream stream(data_inside_base58.data(), data_inside_base58.size());
	seria::BinaryInputStream ba(stream);
	ba.begin_object();
	SendproofAmethyst sp;
	try {
		seria::ser_members(sp, ba);
	} catch (const std::exception &) {
		std::throw_with_nested(
		    api::cnd::CheckSendproof::Error(api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object"));
	}
	if (sp.version < m_block_chain.get_currency().amethyst_transaction_version) {
		ba.end_object();
		if (!stream.empty())
			throw api::cnd::CheckSendproof::Error(
			    api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object - too many bytes");
		SendproofLegacy spk;
		spk.transaction_hash = sp.transaction_hash;
		spk.message          = sp.message;
		spk.address          = m_block_chain.get_currency().account_address_as_string(sp.address_simple);
		spk.derivation       = sp.derivation;
		spk.signature        = sp.signature;
		check_sendproof(spk, response);
		return;
	}
	BinaryArray binary_tx;
	Height height = 0;
	Hash block_hash;
	size_t index_in_block = 0;
	if (!m_block_chain.get_transaction(sp.transaction_hash, &binary_tx, &height, &block_hash, &index_in_block)) {
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::NOT_IN_MAIN_CHAIN, "Transaction is not in main chain");
	}
	Transaction tx;
	seria::from_binary(tx, binary_tx);
	if (tx.inputs.empty() || tx.inputs.at(0).type() != typeid(InputKey))
		throw api::cnd::CheckSendproof::Error(api::cnd::CheckSendproof::FAILED_TO_PARSE,
		    "Proof object invalid, because references coinbase transactions");
	if (tx.version != sp.version)
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION, "Proof version wrong for transaction version");
	const Hash tx_inputs_hash = get_transaction_inputs_hash(tx);

	const InputKey &in = boost::get<InputKey>(tx.inputs.at(0));
	TransactionPrefix fake_prefix;
	fake_prefix.version = tx.version;
	fake_prefix.inputs.push_back(in);
	RingSignatureAmethyst rsa;
	try {
		seria::ser_members(rsa, ba, fake_prefix);
	} catch (const std::exception &) {
		std::throw_with_nested(
		    api::cnd::CheckSendproof::Error(api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object"));
	}
	ba.end_object();
	if (!stream.empty())
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object - too many bytes");

	const auto proof_body = seria::to_binary(sp);
	//	std::cout << "Proof body: " << common::to_hex(proof_body) << std::endl;
	const auto proof_prefix_hash = crypto::cn_fast_hash(proof_body);
	//	std::cout << "Proof hash: " << proof_prefix_hash << std::endl;

	std::vector<KeyImage> all_keyimages{in.key_image};
	std::vector<std::vector<PublicKey>> all_output_keys{m_block_chain.get_mixed_public_keys(in)};

	if (!crypto::check_ring_signature_amethyst(proof_prefix_hash, all_keyimages, all_output_keys, rsa)) {
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::WRONG_SIGNATURE, "Proof object does not match transaction or was tampered with");
	}
	for (size_t oi = 1; oi < sp.elements.size(); ++oi) {
		if (sp.elements.at(oi).out_index <= sp.elements.at(oi - 1).out_index)
			throw api::cnd::CheckSendproof::Error(
			    api::cnd::CheckSendproof::WRONG_SIGNATURE, "Proof object elements are not in strict ascending order");
	}
	std::reverse(sp.elements.begin(), sp.elements.end());  // pop_back instead of erase(begin)
	Amount total_amount = 0;
	boost::optional<AccountAddress> all_addresses;
	for (size_t out_index = 0; out_index != tx.outputs.size() && !sp.elements.empty(); ++out_index) {
		const auto &output = tx.outputs.at(out_index);
		if (output.type() != typeid(OutputKey))
			continue;
		const auto &key_output = boost::get<OutputKey>(output);
		if (sp.elements.back().out_index != out_index)
			continue;
		const auto &el = sp.elements.back();
		AccountAddress output_address;
		if (!TransactionBuilder::detect_not_our_output_amethyst(
		        tx_inputs_hash, el.output_seed, out_index, key_output, &output_address)) {
			throw api::cnd::CheckSendproof::Error(
			    api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION, "Cannot underive address for proof output");
		}
		if (all_addresses && all_addresses.get() != output_address) {
			throw api::cnd::CheckSendproof::Error(
			    api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION, "Send proof address inconsistent");
		}
		all_addresses = output_address;
		total_amount += key_output.amount;
		response.output_indexes.push_back(out_index);
		sp.elements.pop_back();
	}
	if (!sp.elements.empty())
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::WRONG_SIGNATURE, "Proof object contains excess elements");
	if (total_amount == 0 || !all_addresses)
		throw api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::ADDRESS_NOT_IN_TRANSACTION, "No transfers found to proof address");
	response.transaction_hash = sp.transaction_hash;
	response.address          = m_block_chain.get_currency().account_address_as_string(all_addresses.get());
	;
	response.message = sp.message;
	response.amount  = total_amount;
}

bool Node::on_check_sendproof(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::CheckSendproof::Request &&request, api::cnd::CheckSendproof::Response &response) {
	uint64_t utag = 0;
	BinaryArray data_inside_base58;
	if (common::base58::decode_addr(request.sendproof, &utag, &data_inside_base58)) {
		if (utag != m_block_chain.get_currency().sendproof_base58_prefix)
			throw api::cnd::CheckSendproof::Error(
			    api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object, wrong prefix");
		check_sendproof(data_inside_base58, response);
		return true;
	}
	SendproofLegacy sp;
	try {
		common::JsonValue jv = common::JsonValue::from_string(request.sendproof);
		seria::from_json_value(sp, jv);
	} catch (const std::exception &ex) {
		std::throw_with_nested(api::cnd::CheckSendproof::Error(
		    api::cnd::CheckSendproof::FAILED_TO_PARSE, "Failed to parse proof object ex.what=" + common::what(ex)));
	}
	check_sendproof(sp, response);
	return true;
}

void Node::submit_block(const BinaryArray &blockblob, api::BlockHeader *info) {
	BlockTemplate block_template;
	seria::from_binary(block_template, blockblob);
	RawBlock raw_block;
	try {
		if (!m_block_chain.add_mined_block(blockblob, &raw_block, info))
			return;
	} catch (const std::exception &ex) {
		throw json_rpc::Error{
		    api::cnd::SubmitBlock::BLOCK_NOT_ACCEPTED, "Block not accepted, reason=" + common::what(ex)};
	}
	for (auto who : m_broadcast_protocols)
		who->advance_transactions();
	p2p::RelayBlock::Notify msg;
	msg.b                         = std::move(raw_block);  // RawBlockLegacy{raw_block.block, raw_block.transactions};
	msg.hop                       = 1;
	msg.current_blockchain_height = m_block_chain.get_tip_height();
	msg.top_id                    = m_block_chain.get_tip_bid();
	p2p::RelayBlock::Notify msg_v4;
	msg_v4.b.block                   = msg.b.block;
	msg_v4.current_blockchain_height = msg.current_blockchain_height;
	msg_v4.top_id                    = msg.top_id;
	msg_v4.hop                       = msg.hop;

	msg.top_id = Hash{};  // TODO - uncomment after 3.4 fork. This is workaround of bug in 3.2

	BinaryArray raw_msg    = LevinProtocol::send(msg);
	BinaryArray raw_msg_v4 = LevinProtocol::send(msg_v4);
	broadcast(nullptr, raw_msg, raw_msg_v4);
	advance_long_poll();
}

bool Node::on_submitblock(http::Client *, http::RequestBody &&, json_rpc::Request &&,
    api::cnd::SubmitBlock::Request &&req, api::cnd::SubmitBlock::Response &res) {
	if (!req.cm_nonce.empty()) {
#if infinium_ALLOW_CM
		// Experimental, a bit hacky
		BlockTemplate bt;
		seria::from_binary(bt, req.blocktemplate_blob);
		bt.major_version += 1;
		bt.nonce               = req.cm_nonce;
		bt.cm_merkle_branch    = req.cm_merkle_branch;
		req.blocktemplate_blob = seria::to_binary(bt);
		//		auto body_proxy = get_body_proxy_from_template(bt);
		//		auto cm_prehash  = get_auxiliary_block_header_hash(bt, body_proxy);
		//		std::cout << "submit CM data " << body_proxy.transactions_merkle_root << " " << cm_prehash << std::endl;
#else
		throw json_rpc::Error{
		    api::cnd::SubmitBlock::BLOCK_NOT_ACCEPTED, "Block not accepted, CM mining is not supported"};
#endif
	}
	submit_block(req.blocktemplate_blob, &res.block_header);
	res.orphan_status = !m_block_chain.in_chain(res.block_header.height, res.block_header.hash);
	res.depth = api::HeightOrDepth(res.block_header.height) - api::HeightOrDepth(m_block_chain.get_tip_height()) - 1;
	return true;
}
